	private Response execute(final Request request) {
		try {
			return httpClient.newCall(request).execute();
		} catch (IOException e) {
			if (e instanceof SSLException && e.getMessage() != null
					&& e.getMessage().contains("Unrecognized SSL message, plaintext connection?")) {
				throw new CerberusClientException(
						"I/O error while communicating with Cerberus. Unrecognized SSL message may be due to a web proxy e.g. AnyConnect",
						e);
			} else {
				throw new CerberusClientException("I/O error while communicating with Cerberus.", e);
			}
		}
	}
	
/**
     * List operation for the specified path.  Will return a {@link Map} with a single entry of keys which is an
     * array of strings that represents the keys at that path. If Cerberus returns an unexpected response code, a
     * {@link CerberusServerException} will be thrown with the code and error details.  If an unexpected I/O error is
     * encountered, a {@link CerberusClientException} will be thrown wrapping the underlying exception.
     * <p>
     * See https://www.cerberusproject.io/docs/secrets/generic/index.html for details on what the list operation returns.
     * </p>
     *
     * @param path Path to the data
     * @return Map containing the keys at that path
     */
    public CerberusListResponse list(final String path) {

        final HttpUrl httpUrl = buildUrl(SECRET_PATH_PREFIX, path + "?list=true");
        logger.debug("list: requestUrl={}", httpUrl);

        final Response response = ofSupplier(
                    () -> execute(httpUrl, HttpMethod.GET, null)
            )
            .withRetry(RETRY)
            .decorate()
            .get();

        if (response.code() == HttpStatus.NOT_FOUND) {
            response.close();
            return new CerberusListResponse();
        } else if (response.code() != HttpStatus.OK) {
            parseAndThrowApiErrorResponse(response);
        }

        final Type mapType = new TypeToken<Map<String, Object>>() {
        }.getType();
        final Map<String, Object> rootData = parseResponseBody(response, mapType);
        return gson.fromJson(gson.toJson(rootData.get("data")), CerberusListResponse.class);
    }

    /**
     * Lists all files at the specified path. Will return a {@link Map} that contains a paginated list
     * of secure file summaries. If Cerberus returns an unexpected response code, a {@link CerberusServerException}
     * will be thrown with the code and error details.  If an unexpected I/O error is
     * encountered, a {@link CerberusClientException} will be thrown wrapping the underlying exception.
     * <p>
     * See https://www.github.com/Nike-Inc/cerberus-management-service/blob/master/API.md for details on what the
     * list files operation returns.
     * </p>
     *
     * @param path Path to the data
     * @return Cerberus response object that lists file metadata
     */
    public CerberusListFilesResponse listFiles(final String path) {
        return listFiles(path, null, null);
    }

    /**
     * Lists all files at the specified path.  Will return a {@link Map} that contains a paginated list
     * of secure file summaries. If Cerberus returns an unexpected response code, a {@link CerberusServerException}
     * will be thrown with the code and error details.  If an unexpected I/O error is
     * encountered, a {@link CerberusClientException} will be thrown wrapping the underlying exception.
     * <p>
     * See https://www.github.com/Nike-Inc/cerberus-management-service/blob/master/API.md for details on what the
     * list files operation returns.
     * </p>
     *
     * @param path   Path to the data
     * @param limit  The max number of results to return
     * @param offset The number offset of results to return
     * @return List of metadata for secure files at the specified path
     */
    public CerberusListFilesResponse listFiles(final String path, Integer limit, Integer offset) {
        final HttpUrl httpUrl = buildUrl("v1/secure-files/", path, limit, offset);

        logger.debug("list: requestUrl={}, limit={}, offset={}", httpUrl, limit, offset);
        final Response response = ofSupplier(
                () -> execute(httpUrl, HttpMethod.GET, null)
        )
                .withRetry(RETRY)
                .decorate()
                .get();

        if (response.code() != HttpStatus.OK) {
            parseAndThrowApiErrorResponse(response);
        }

        return parseResponseBody(response, CerberusListFilesResponse.class);
    }

    /**
     * Read operation for a specified path.  Will return a {@link Map} of the data stored at the specified path.
     * If Cerberus returns an unexpected response code, a {@link CerberusServerException} will be thrown with the code
     * and error details.  If an unexpected I/O error is encountered, a {@link CerberusClientException} will be thrown
     * wrapping the underlying exception.
     *
     * @param path Path to the data
     * @return Map of the data
     */
    public CerberusResponse read(final String path) {
        final HttpUrl httpUrl = buildUrl(SECRET_PATH_PREFIX, path);
        logger.debug("read: requestUrl={}", httpUrl);

        final Response response = ofSupplier(
                () -> execute(httpUrl, HttpMethod.GET, null)
        )
        .withRetry(RETRY)
        .decorate()
        .get();

        if (response.code() != HttpStatus.OK) {
            parseAndThrowApiErrorResponse(response);
        }

        return parseResponseBody(response, CerberusResponse.class);
    }

    /**
     * Read the binary contents of the file at the specified path. Will return the file contents stored at the specified path.
     * If Cerberus returns an unexpected response code, a {@link CerberusServerException} will be thrown with the code
     * and error details.  If an unexpected I/O error is encountered, a {@link CerberusClientException} will be thrown
     * wrapping the underlying exception.
     *
     * @param path Path to the data
     * @return File contents
     */
    public byte[] readFileAsBytes(final String path) {
        final HttpUrl httpUrl = buildUrl(SECURE_FILE_PATH_PREFIX, path);
        logger.debug("read: requestUrl={}", httpUrl);

        final Response response = ofSupplier(
                () -> execute(httpUrl, HttpMethod.GET, null)
        )
                .withRetry(RETRY)
                .decorate()
                .get();

        if (response.code() != HttpStatus.OK) {
            parseAndThrowApiErrorResponse(response);
        }

        return responseBodyAsBytes(response);
    }

    /**
     * Write operation for a specified path and data set. If Cerberus returns an unexpected response code, a
     * {@link CerberusServerException} will be thrown with the code and error details.  If an unexpected I/O
     * error is encountered, a {@link CerberusClientException} will be thrown wrapping the underlying exception.
     *
     * @param path Path for where to store the data
     * @param data Data to be stored
     */
    public void write(final String path, final Map<String, String> data) {
        final HttpUrl httpUrl = buildUrl(SECRET_PATH_PREFIX, path);
        logger.debug("write: requestUrl={}", httpUrl);

        final Response response = ofSupplier(
                () -> execute(httpUrl, HttpMethod.POST, data)
        )
                .withRetry(RETRY)
                .decorate()
                .get();

        if (response.code() != HttpStatus.NO_CONTENT) {
            parseAndThrowApiErrorResponse(response);
        }
    }

    /**
     * Write operation for file at specified path with given content. If Cerberus returns an unexpected response code, a
     * {@link CerberusServerException} will be thrown with the code and error details.  If an unexpected I/O
     * error is encountered, a {@link CerberusClientException} will be thrown wrapping the underlying exception.
     *
     * @param path     Path for where to store the data
     * @param contents File contents to be stored
     */
    public void writeFile(final String path, final byte[] contents) {
        final String fileName = StringUtils.substringAfterLast(path, "/");
        final HttpUrl httpUrl = buildUrl(SECURE_FILE_PATH_PREFIX, path);
        logger.debug("write: requestUrl={}", httpUrl);

        RequestBody requestBody = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("file-content", fileName,
                        RequestBody.create(MediaType.parse("application/octet-stream"), contents))
                .build();

        Request request = new Request.Builder()
                .url(httpUrl)
                .headers(defaultHeaders)
                .addHeader(HttpHeader.CERBERUS_TOKEN, credentialsProvider.getCredentials().getToken())
                .addHeader(HttpHeader.ACCEPT, DEFAULT_MEDIA_TYPE.toString())
                .post(requestBody)
                .build();

        final Response response = execute(request);

        if (response.code() != HttpStatus.NO_CONTENT) {
            parseAndThrowApiErrorResponse(response);
        }
    }

    /**
     * Delete operation for a file path.  If Cerberus returns an unexpected response code, a
     * {@link CerberusServerException} will be thrown with the code and error details.  If an unexpected I/O
     * error is encountered, a {@link CerberusClientException} will be thrown wrapping the underlying exception.
     *
     * @param path Path to file to be deleted
     */
    public void deleteFile(final String path) {
        final HttpUrl httpUrl = buildUrl(SECURE_FILE_PATH_PREFIX, path);
        logger.debug("delete: requestUrl={}", httpUrl);

        final Response response = ofSupplier(
                () -> execute(httpUrl, HttpMethod.DELETE, null)
        )
                .withRetry(RETRY)
                .decorate()
                .get();

        if (response.code() != HttpStatus.NO_CONTENT) {
            parseAndThrowApiErrorResponse(response);
        }
    }

    /**
     * Delete operation for a specified path.  If Cerberus returns an unexpected response code, a
     * {@link CerberusServerException} will be thrown with the code and error details.  If an unexpected I/O
     * error is encountered, a {@link CerberusClientException} will be thrown wrapping the underlying exception.
     *
     * @param path Path to data to be deleted
     */
    public void delete(final String path) {
        final HttpUrl httpUrl = buildUrl(SECRET_PATH_PREFIX, path);
        logger.debug("delete: requestUrl={}", httpUrl);

        final Response response = ofSupplier(
                () -> execute(httpUrl, HttpMethod.DELETE, null)
        )
                .withRetry(RETRY)
                .decorate()
                .get();

        if (response.code() != HttpStatus.NO_CONTENT) {
            parseAndThrowApiErrorResponse(response);
        }
    }	
    
    
    	protected HttpUrl buildUrl(final String prefix, final String path, final Integer limit, final Integer offset) {
		String baseUrl = url;
		baseUrl = StringUtils.appendIfMissing(baseUrl, "/");

		final StringBuilder fullUrl = new StringBuilder().append(baseUrl).append(prefix).append(path);

		if (limit != null && offset != null) {
			fullUrl.append("?limit=").append(limit).append("&offset=").append(offset);
		} else if (limit != null) {
			fullUrl.append("?limit=").append(limit);
		} else if (offset != null) {
			fullUrl.append("?offset=").append(offset);
		}

		return HttpUrl.parse(fullUrl.toString());
	}